var documenterSearchIndex = {"docs":
[{"location":"Library/#home","page":"Practice","title":"home","text":"","category":"section"},{"location":"Library/","page":"Practice","title":"Practice","text":"  Gillespie developed a stochastic simulation algorithm (SSA)[J. Phys. Chem.81, 2350(1977)] to simulate stochastic dynamics of chemically reacting systems.In this algorithm, it is assumed that all reactions occur instantly.Since Gillespie’s exact SSA was developed for chemical reaction systems without delay, it is apparent that Gillespie’s SSA cannot produce exact simulation results for chemical reaction systems with delays.","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"  While this is true in many cases, it is also possible that some chemical reactions, such as gene transcription and translation in living cells, take certain time to finish after they are initiated.Neglecting delays in certain cases may still produce acceptable results, but in some delay-sensitive cases, such as delay-induced oscillators,neglecting delays in simulation will lead to erroneous conclusions.To solve this problem an exact SSA for chemical reaction systems with delays，Delay SSA was proposed, based upon the same fundamental premise of stochastic kinetics used by Gillespie in the development of his SSA.","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"  DelaySSAToolkit.jl is a tool .....","category":"page"},{"location":"Library/#Features","page":"Practice","title":"Features","text":"","category":"section"},{"location":"Library/","page":"Practice","title":"Practice","text":"1\n2\n3","category":"page"},{"location":"Library/#Installation","page":"Practice","title":"Installation","text":"","category":"section"},{"location":"Library/","page":"Practice","title":"Practice","text":"Install with Pkg, just like any other registered Julia package:","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"pkg> add DelaySSAToolkit  # Press ']' to enter the Pkg REPL mode.","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"You can use it by","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"using DelaySSAToolkit\n....","category":"page"},{"location":"Library/#References","page":"Practice","title":"References","text":"","category":"section"},{"location":"Library/","page":"Practice","title":"Practice","text":"[1]: Xiaodong Cai, \"Exact stochastic simulation of coupled chemical reactions with delays\", The Journal of Chemical Physics 126, 124108(2007). https://doi/10.1063/1.2710253.","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"[2]: David F. Anderson, \"A modified Next Reaction Method for simulating chemical systems with time dependent propensities and delays\", The Journal of Chemical Physics 128, 109903(2008). https://doi/10.1063/1.2799998.","category":"page"},{"location":"Library/#home-2","page":"Practice","title":"home","text":"","category":"section"},{"location":"Library/#Algorithms","page":"Practice","title":"Algorithms","text":"","category":"section"},{"location":"Library/","page":"Practice","title":"Practice","text":"  Consider a system consisting of N1 chemical species,X_1     X_N, undergoing M  1 chemical reactions through reaction channels R_1R_M, each of which is equipped with a propensity function (or intensity function in the mathematics literature),a_k(X). The dynamic state of this chemical system can be described by the state vector X(t) =X_1(t)X_N(t)^T, where X_ntn = 1N is the number of X_n molecules at time t, and ^T denotes the transpose of the vector in the bracket.","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"  Delays, tau_k  0, in systems are between the initiation and completion of some, or all, of the reactions. Notice that the definition of tau_k  is not the next reaction time of the Next Reaction Method. We partition the reactions into three sets, those with no delays, denoted ND, those that change the state of the system only upon completion, denoted CD, and those that change the state of the system at both initiation and completion, denoted ICD. The following assumption is based upon physical principles and serves as the base assumption for simulation methods of chemically reacting systems with delays:","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"a_k(X(t)) Delta t + omicron (t) = mathrmthe probability that  reaction k","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"mathrmtakes place in a small time interval t t + Delta t)","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"beginaligned\na_k(X(t)) Delta t + omicron (t) = mathrmthe probability that  reaction k\n= mathrmtakes place in a small time interval t t + Delta t)\nendaligned","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"where omicron (Delta t)Delta t rightarrow 0  as  Delta t rightarrow 0.","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"  Thus, no matter whether a reaction is contained in ND, CD, or ICD, the number ofinitiationsat absolute timetwill be given by","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"mathrmnumber of initiations of reaction k mathrmby time t = Y_k(int_0^t a_k(X(s)) mathrmds)","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"where the Y_k are independent, unit rate Poisson processes.","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"  Because the assumption above, and hence equation t, only pertains to the initiation times of reactions we must handle the completions separately. There are three different types of reactions, so there are three cases that need consideration.","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"Case 1: If reaction k is in ND and initiates at time t, then the system is updated by losing the reactant species and gaining the product species at the time of initiation.","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"Case 2: If reaction k is in CD and initiates at time t, then the system is updated only at the time of completion, t + tau_k, by losing the reactant species and gaining the product species.","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"Case 3: If reaction k is in ICD and initiates at time t, then the system is updated by losing the reactant species at the time of initiation, t, and is updated by gaining the product species at the time of completion,t + tau_k.","category":"page"},{"location":"Library/#The-Rejection-Method","page":"Practice","title":"The Rejection Method","text":"","category":"section"},{"location":"Library/","page":"Practice","title":"Practice","text":"  Simulation methods for systems with delays need to calculate when reactions initiate and store when they complete. However, because of the delayed reactions, the propensity functions can change between initiation times. Bratsun et al. and Barrio et al. used an algorithm for computing the initiation times that is exactly like the original Gillespie Algorithm except that if there is a stored delayed reaction set to finish within a computed timestep, then the computed timestep is discarded, and the system is updated to incorporate the stored delayed reaction. The algorithm then attempts another step starting at its new state. This algorithm is called Rejection Method.","category":"page"},{"location":"Library/#Pseudo-code","page":"Practice","title":"Pseudo code","text":"","category":"section"},{"location":"Library/","page":"Practice","title":"Practice","text":"Initialize. Set the initial number of molecules of each species and set t = 0.\nCalculate the propensity function,a_k, for each reaction.\nSet a_0 = beginmatrix sum_k=1^M a_k endmatrix.\nGenerate an independent uniform(0,1) random number,r_1, and set Delta = 1a_0ln(1r_1).\nIf there is a delayed reaction set to finish in t t + Delta)\n(a) Discard Delta.\n(b) Updatetto be the time of the next delayed reaction,mu.\n(c) Updatexaccording to the stored reaction mu.\n(d) Return to step 2 or quit.\nElse\n(a) Generate an independent uniform(01) random number r_2.\n(b) Find muin1 m such that","category":"page"},{"location":"Library/#Direct-Method-for-systems-with-delays","page":"Practice","title":"Direct Method for systems with delays","text":"","category":"section"},{"location":"Library/","page":"Practice","title":"Practice","text":"  The number of discarded Delta s will be approximately equal to the number of delayed reactions that initiate. This follows because, other than the stored completions at the time the script terminates, every delayed completion will cause one computed Delta to be discarded.","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"  The percentage of random numbers generated in step 4 and discarded in step 5a in above pseudo code for The Rejection Method can approach 50%. Cai then develops an algorithm, called the Direct Method for systems with delays, in which no random variables are discarded.","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"  The principle of Direct Method is the same as that of the original Gillespie Algorithm and the Rejection Method above: use one random variable to calculate when the next reaction initiates and use another random variable to calculate which reaction occurs at that future time. However, Direct Method updates the state of the system and propensity functions due to stored delayed reactions during the search for the next initiation time. In this way he ensures that no random variables are discarded as in the Rejection Method.","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"  Suppose that at time t there are ongoing delayed reactions set to complete at times t + T_1 t + T_2     t + T_d. Define T_0 = 0 and T_d + 1 = infty.","category":"page"},{"location":"Library/#Pseudo-code-2","page":"Practice","title":"Pseudo code","text":"","category":"section"},{"location":"Library/#Next-Reaction-Method-for-systems-with-delays","page":"Practice","title":"Next Reaction Method for systems with delays","text":"","category":"section"},{"location":"Library/","page":"Practice","title":"Practice","text":"  Because the initiations are still given by the firing times of independent Poisson processes. Therefore, if T_k is the current internal time of Y_k, P_k the first internal time after T_k at which Y_k fires, and the propensity function for the kth reaction channel is given by a_k, then the time until the next initiation of reaction k(assuming no other reactions initiate or complete) is still given by Delta t_k= (P_kT_k)a_k. The only change to the algorithm will be in keeping track and storing the delayed completions. To each delayed reaction channel we therefore assign a vector, s_k, that stores the completion times of that reaction in ascending order. Thus, the time until there is a change in the state of the system, be it an initiation or a completion, will be given by:","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"Delta = min_kDelta t_k s_k(1)  t","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"  where t is the current time of the system. These ideas form the heart of our Next Reaction Method for systems with delays.","category":"page"},{"location":"Library/#Pseudo-code-3","page":"Practice","title":"Pseudo code","text":"","category":"section"},{"location":"Library/","page":"Practice","title":"Practice","text":"Initialize. Set the initial number of molecules of each species and set t = 0. For each k  M, set P_k = 0 and T_k = 0, and for each delayed reaction channel set s_k = infty.\nCalculate the propensity function, a_k, for each reaction.\nGenerate M independent, uniform(01) random numbers, r_k, and set P_k = ln(1r_k).\nSet Delta t_k = min_k(P_k  T_k)a_k.\nSet Delta = min_kDelta t_k s_k(1)  t.\nSet t = t + Delta.\nIf we chose the completion of the delayed reaction mu:\nUpdate the system based upon the completion of the reaction mu.\nDelete the first row of S_mu.\nElseif reaction mu initiated and muin ND\nUpdate the system according to reaction mu.\nElseif reaction mu initiated and muin CD\nUpdate sµ by inserting t + tau_mu into s_mu in the second to last position.\nElseif reaction mu initiated and muin ICD\nUpdate the system based upon the initiation of reaction mu.\nUpdate s_mu by inserting t + tau_mu into s_mu in the second to last position.\nFor each k, set min_kT_k = min_kT_k + a_kDelta.\nIf reaction mu initiated, let r be uniform(01) and set P_µ = P_µ + ln(1r).\nRecalculate the propensity functions, a_k.\nReturn to step 4 or quit.","category":"page"},{"location":"Library/#References-2","page":"Practice","title":"References","text":"","category":"section"},{"location":"Library/","page":"Practice","title":"Practice","text":"[1]: Xiaodong Cai, \"Exact stochastic simulation of coupled chemical reactions with delays\", The Journal of Chemical Physics 126, 124108(2007). https://doi/10.1063/1.2710253.","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"[2]: David F. Anderson, \"A modified Next Reaction Method for simulating chemical systems with time dependent propensities and delays\", The Journal of Chemical Physics 128, 109903(2008). https://doi/10.1063/1.2799998.","category":"page"},{"location":"Library/#Theory","page":"Practice","title":"Theory","text":"","category":"section"},{"location":"Library/#Exact-SSA-For-Coupled-Chemical-Reaction-Without-Delays","page":"Practice","title":"Exact SSA For Coupled Chemical Reaction Without Delays","text":"","category":"section"},{"location":"Library/","page":"Practice","title":"Practice","text":"  Consider a system consisting of N1 chemical species, X_1     X_N, undergoing M  1 chemical reactions through reaction channels R_1R_M, each of which is equipped with a propensity function (or intensity function in the mathematics literature), a_k(X). The dynamic state of this chemical system can be described by the state vector mathbfX(t) =X_1(t)X_N(t)^T, where X_ntn = 1N is the number of X_n molecules at time t, and ^T denotes the transpose of the vector in the bracket.","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"  Following Gillespie, A the dynamics of reaction R_m defined by a state-change vector mathbfnu_m = nu_1m nu_Nm^T, where nu_nm gives the changes in the X_n molecular population produced by one R_m reaction, and a propensity function a_m(t) together with the fundamental premise of stochastic chemical kinetics:","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"beginequation\na_m(t)dt=mathrmthe probability given mathbfX(t)=mathbfx \nmathrmthat one reaction R_m mathrm will occur in the \nmathrmnext infinitesimal time interval tt+d_t\nendequation","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"  Defining the probability rate constant c_m as the probability that a randomly selected combination of R_m reactant molecules reacts in a unit time period, we can calculate  a_m(t) fromcmand the molecular numbers ofRmreactants at time t using the method given by Gillespie.   For a chemical system in a given state mathbfX(t)=mathbfx at time t,assuming that all reactions occur instantly, Gillespie’s exact SSA answers the following two questions: (i)  when will the next reaction occur?  (ii)  which reaction will occur? Specifically, Gillespie’s exact SSA simulates the following event in each step:","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"beginequation\nmathrmEno reaction occurs in the time interval tt+tau\nmathrmand a reaction R_mu  mathrmoccurs in the infinitesimal\nmathrmtime interval t+taut+tau+d_tau\nendequation","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"  Based upon the fundamental premise (1), Gillespie showed that that tau and muare two independent random variables and have the following probability density functions (PDFs), respectively:","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"beginequation\nf_tau(tau)=a_0(t) exp(-a_0(t)tau) tau  0\nendequation","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"and","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"beginequation\nf_mu(mu)=a_mu(t)a_0(t) mu = 1M\nendequation","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"where a_0(t)=beginmatrix sum_m=1^M a_m(t) endmatrix. According to the PDF(4), a realization of mu can be generated from a standard uniform random variable u_1, by taking mu to be the integer for which beginmatrix sum_j=1^mu-1 a_j(t) endmatrix  u_1 a_0(t)  beginmatrix sum_j=1^mu a_j(t) endmatrix;based on the PDF (3), a realization of taucan be generated from another standard uniform random variable u_2 as tau=ln(u_2)a_0(t). Therefore, Gillespie’s exact SSA generates a realization of mu and tau in each step of simulation, and then updates the time and system state as tleftarrow t+tau and  mathbfx leftarrow mathbfx+ mathbfnu_mu, respectively.","category":"page"},{"location":"Library/#Exact-SSA-For-Coupled-Chemical-Reaction-With-Delays","page":"Practice","title":"Exact SSA For Coupled Chemical Reaction With Delays","text":"","category":"section"},{"location":"Library/#Direct-method","page":"Practice","title":"Direct method","text":"","category":"section"},{"location":"Library/","page":"Practice","title":"Practice","text":"  As in the derivation of Gillespie’s exact SSA, we first need to find the probability of event (2), that is defined as P(taumu)dtau, where P(taumu) is the joint PDF of tau and mu. Suppose that there are d ongoing reactions at timet, which will finish at t+T_1t+T_d, respectively. Without loss of generality, we assume that T_1T_2T_d. Unlike in the reaction system without delays where the propensity functions remain unchanged in the time interval tt+tau, the propensity functions here change at t+T_ii=1d, due to delayed reactions. We need to take into account such changes in propensity functions when deriving  P(taumu).","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"  As in the derivation of Gillespie’s exact SSA,P(taumu)dtau can be found from the fundamental premise(1) as","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"beginequation\nP(taumu)dtau=P_0(tau) a_mu(taumu)dtau\nendequation","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"where P_0(tau) is the probability that no reaction will occur in the time interval tt+tau, while a_mu(t+tau)dtauis the probability that a reaction R_mu occurs in t+taut+tau+dtau. Defining T_0=0 and T_d+1=infty, we can find P_0(tau) for tau that lies in different time intervals T_iT_i+1)i=0d. If tau in T_iT_i+1), we define the event E_j as the event that no reaction occurs in the time interval t+T_jt+T_j+1)j=0j=i1, respectively,and the event  E_i  as the event that no reaction occurs in the time interval t+T_it+tau). Then, we can express P_0(tau) as","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"beginequation\nP_0(tau)=P(E_0E_i)=P(E_0) prod_j=1^i P(E_j丨E_0E_j)\nendequation","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"From the derivation of Gillespie’s exact SSA,we know that  P(E0) = expa_0(t)T_1),  P(E_j丨E_0E_j-1) = exp(-a_0(t+T_j)T_1)  (T_j+1T_j)j=0i1,   and   P(E_i丨E_0E_i-1) = exp(-a_0(t+T_i)(tau-T_i)).  Notice that propensity functions change at t+T_j after a delayed reaction finishes, and we use a_0(t+T_j) to represent the new a_0. The probability P_0(tau) is then given by","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"beginequation\nP_0(tau)=exp(-beginmatrix sum_j=0^i-1 a_0(t+T_j)(T_j+1-T_j) endmatrix-a_0(t+T_i)(tau-T_i)) \ntau in T_iT_i+1) i = 0d\nbeginequation","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"where we assume that the first term of the exponent is equal to zero when i = 0. Since P_0(tau) does not depend on individual propensity functions, as shown in Eq.(7), it is seen from Eq.(5) that tau and mu are independent random variables. Combining Eqs.(5) and (7) and noticing that a_mu(t+tau)=a_mu(t+T_i) for tau in T_iT_i+1), we obtain the PDF of tau and mu as follows:","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"beginequation\nf_tau(tau)=a_0(t+T_i)exp(-beginmatrix sum_j=0^i-1 a_0(t+T_j)(T_j+1-T_j) endmatrix-a_0(t+T_i)(tau-T_i)) \ntau in T_iT_i+1) i = 0d\nbeginequation","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"and","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"beginequation\nf_mu(mu)=a_mu(t+T_i)a_0(t+T_i) mu = 1Mtau in T_iT_i+1)\nbeginequation","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"It is not difficult to verify that int_0^infty f_tau(tau) dx = 1. In simulation, mu can be generated, from a standard uniform random variable u_1, by taking mu to be the integer for which beginmatrix sum_j=1^mu-1 a_j(t+T_i) endmatrix  u_1 a_0(t+T_i)  beginmatrix sum_j=1^mu a_j(t+T_i) endmatrix,after tau is generated to be in the time interval T_iT_i+1).We next derive the method of generating  tau according to its PDF in Eq.(8).   The cumulative distribution function of taucan be found from Eq.(8) as","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"beginequation\nF_tau(tau)=1 - exp(-beginmatrix sum_j=0^i-1 a_0(t+T_j)(T_j+1-T_j) endmatrix-a_0(t+T_i)(tau-T_i)) \ntau in T_iT_i+1) i = 0d\nbeginequation","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"Then, we can generate tau from a standard uniform random variable u_2, by taking tau=F_tau^1(u2), where F_tau^1(cdot) represents the inverse of F_tau(tau). More specifically, we can obtain tau as follows:   Find T_i such that  F_tau(T_i)  u_2  F_tau(T_i+1), then calculate  tau from","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"beginequation\ntau = T_i + -ln (1-u_2)-beginmatrix sum_j=0^i-1 a_0(t+T_j)(T_j+1-T_j)  over a_0(t+T_j)\ntau in T_iT_i+1)\nbeginequation","category":"page"},{"location":"Library/#Rejection-method","page":"Practice","title":"Rejection method","text":"","category":"section"},{"location":"Library/","page":"Practice","title":"Practice","text":"Now let us see whether the rejection method can correctly simulate the event（2）. Rejection method generates tau in an iterative fashion: in the ith iteration, it generates a tau_i according to an exponential PDF with parameter a_0(t+T_i1), where we have denoted the tau generated in the ith iteration of step 2 as tau_i. If tau_iT_iT_i1, then we have tau=beginmatrix sum_j=1^i-1 T_j+tau_i endmatrix and the algorithm continues simulation to generate mu; otherwise, it rejects tau_i, updates the state vector X(t+T_i), calculates a_m(t+T_i)m=1M and goes to the next iteration. If tau is determined in the (i+1)th iteration, where i is a non-negative integer,","category":"page"},{"location":"Library/#Tutorials","page":"Practice","title":"Tutorials","text":"","category":"section"},{"location":"Library/#Delay-Jump-Problems","page":"Practice","title":"Delay Jump Problems","text":"","category":"section"},{"location":"Library/#Defining-a-Delay-Jump-Problem","page":"Practice","title":"Defining a Delay Jump Problem","text":"","category":"section"},{"location":"Library/#API","page":"Practice","title":"API","text":"","category":"section"},{"location":"Library/#练习page","page":"Practice","title":"练习page","text":"","category":"section"},{"location":"Library/","page":"Practice","title":"Practice","text":"这一页的content","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"Pages = [\"Library.md\"]","category":"page"},{"location":"Library/#Formula","page":"Practice","title":"Formula","text":"","category":"section"},{"location":"Library/","page":"Practice","title":"Practice","text":"一个点括起来表示程序，两个点括起来表示LaTeX公式，三个点括起来表示引用指定的宏来制作文档。","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"在MyPkg/docs/src/里的.md文件中，LaTeX的转义\\sqrt[n]{1 + x + x^2 + \\ldots}这里要写1条\\","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"而MyPkg/src/里的.jl文件中使用三个双引号括起来的形式，称为docstring，则需要两条\\\\，来表示LaTeX的转义\\\\sqrt[n]{1 + x + x^2 + \\\\ldots}","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"Here's a example maths:sqrtn1 + x + x^2 + ldots.","category":"page"},{"location":"Library/#Cross-Reference","page":"Practice","title":"Cross Reference","text":"","category":"section"},{"location":"Library/","page":"Practice","title":"Practice","text":"link to MyPkg\nlink to Simpson(f, a, b)\nlink to function","category":"page"},{"location":"Library/#URL","page":"Practice","title":"URL","text":"","category":"section"},{"location":"Library/","page":"Practice","title":"Practice","text":"外部链接","category":"page"},{"location":"Library/","page":"Practice","title":"Practice","text":"More detail in Document.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MyPkg","category":"page"},{"location":"#DelaySSAToolkit","page":"Home","title":"DelaySSAToolkit","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"  Gillespie developed a stochastic simulation algorithm (SSA)[1] to simulate stochastic dynamics of chemically reacting systems. In this algorithm, it is assumed that all reactions occur instantly.Since Gillespie’s exact SSA was developed for chemical reaction systems without delay, it is apparent that Gillespie’s SSA cannot produce exact simulation results for chemical reaction systems with delays.","category":"page"},{"location":"","page":"Home","title":"Home","text":"  While this is true in many cases, it is also possible that some chemical reactions, such as gene transcription and translation in living cells, take certain time to finish after they are initiated. Neglecting delays in certain cases may still produce acceptable results, but in some delay-sensitive cases, such as delay-induced oscillators,neglecting delays in simulation will lead to erroneous conclusions.To solve this problem an exact SSA for chemical reaction systems with delays，Delay SSA[2,3] was proposed, based upon the same fundamental premise of stochastic kinetics used by Gillespie in the development of his SSA.","category":"page"},{"location":"","page":"Home","title":"Home","text":"  DelaySSAToolkit.jl is a tool ..... contains three algorithms of delay SSA, namely The Rejection Method, Direct Method and Next Reaction Method. You can call any algorithm to ...","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"1\n1.1\n1.2\n1.3\n2\n3","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install with Pkg, just like any other registered Julia package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add DelaySSAToolkit  # Press ']' to enter the Pkg REPL mode.","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can use it by","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DelaySSAToolkit\n....","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]: Daniel T. Gillespie \"Exact stochastic simulation of coupled chemical reactions\", J. Phys. Chem. 1977, 81, 25, 2340–2361. https://doi.org/10.1021/j100540a008","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2]: Xiaodong Cai, \"Exact stochastic simulation of coupled chemical reactions with delays\", The Journal of Chemical Physics 126, 124108(2007). https://doi/10.1063/1.2710253.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[3]: David F. Anderson, \"A modified Next Reaction Method for simulating chemical systems with time dependent propensities and delays\", The Journal of Chemical Physics 128, 109903(2008). https://doi/10.1063/1.2799998.","category":"page"},{"location":"#Algorithms","page":"Home","title":"Algorithms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"  Consider a system consisting of N1 chemical species,X_1     X_N, undergoing M  1 chemical reactions through reaction channels R_1R_M, each of which is equipped with a propensity function (or intensity function in the mathematics literature),a_k(X). The dynamic state of this chemical system can be described by the state vector X(t) =X_1(t)X_N(t)^T, where X_ntn = 1N is the number of X_n molecules at time t, and ^T denotes the transpose of the vector in the bracket.","category":"page"},{"location":"","page":"Home","title":"Home","text":"  Delays, tau_k  0, in systems are between the initiation and completion of some, or all, of the reactions. Notice that the definition of tau_k  is not the next reaction time of the Next Reaction Method. We partition the reactions into three sets, those with no delays, denoted ND, those that change the state of the system only upon completion, denoted CD, and those that change the state of the system at both initiation and completion, denoted ICD. The following assumption is based upon physical principles and serves as the base assumption for simulation methods of chemically reacting systems with delays:","category":"page"},{"location":"","page":"Home","title":"Home","text":"a_k(X(t)) Delta t + omicron (t) = mathrmthe probability that  reaction k","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathrmtakes place in a small time interval t t + Delta t)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where omicron (Delta t)Delta t rightarrow 0  as  Delta t rightarrow 0.","category":"page"},{"location":"","page":"Home","title":"Home","text":"  Thus, no matter whether a reaction is contained in ND, CD, or ICD, the number ofinitiationsat absolute timetwill be given by","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathrmnumber of initiations of reaction kmathrm by time t = Y_k(int_0^t a_k(X(s)) mathrmds)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where the Y_k are independent, unit rate Poisson processes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"  Because the assumption above, and hence equation t, only pertains to the initiation times of reactions we must handle the completions separately. There are three different types of reactions, so there are three cases that need consideration.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Case 1: If reaction k is in ND and initiates at time t, then the system is updated by losing the reactant species and gaining the product species at the time of initiation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Case 2: If reaction k is in CD and initiates at time t, then the system is updated only at the time of completion, t + tau_k, by losing the reactant species and gaining the product species.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Case 3: If reaction k is in ICD and initiates at time t, then the system is updated by losing the reactant species at the time of initiation, t, and is updated by gaining the product species at the time of completion,t + tau_k.","category":"page"},{"location":"#The-Rejection-Method","page":"Home","title":"The Rejection Method","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"  Simulation methods for systems with delays need to calculate when reactions initiate and store when they complete. However, because of the delayed reactions, the propensity functions can change between initiation times. Bratsun et al.[1] and Barrio et al.[2] used an algorithm for computing the initiation times that is exactly like the original Gillespie Algorithm except that if there is a stored delayed reaction set to finish within a computed timestep, then the computed timestep is discarded, and the system is updated to incorporate the stored delayed reaction. The algorithm then attempts another step starting at its new state. This algorithm is called Rejection Method[3].","category":"page"},{"location":"#Pseudo-code","page":"Home","title":"Pseudo code","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Initialize. Set the initial number of molecules of each species and set t = 0.\nCalculate the propensity function, a_k, for each reaction.\nSet a_0 = beginmatrix sum_k=1^M a_k endmatrix.\nGenerate an independent uniform(01) random number, r_1, and set Delta = 1a_0 ln(1r_1).\nIf there is a delayed reaction set to finish in t t + Delta)\n(a) Discard Delta.\n(b) Updatetto be the time of the next delayed reaction,mu.\n(c) Updatexaccording to the stored reaction mu.\n(d) Return to step 2 or quit.\nElse\n(a) Generate an independent uniform(01) random number r_2.\n(b) Find muin1 m such that\nmath  \\begin{matrix} \\sum_{k=1}^{\\mu-1} a_k(t) \\end{matrix} < r_2 a_0 < \\begin{matrix} \\sum_{k=1}^\\mu a_k(t) \\end{matrix}\n(c) If muin ND, update the number of each molecular species according to reaction mu.\n(d) If muin CD, store the information that at time t+tau_mu the system must be updated according to reaction mu.\n(e) If muin ICD, update the system according to the initiation of mu and store that at time t+tau_mu the system must be updated according to the completion of reaction mu.\n(f) Set t = t +Delta\n(g) Return to step 2 or quit.","category":"page"},{"location":"#Direct-Method-for-systems-with-delays","page":"Home","title":"Direct Method for systems with delays","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"  The number of discarded Delta s will be approximately equal to the number of delayed reactions that initiate. This follows because, other than the stored completions at the time the script terminates, every delayed completion will cause one computed Delta to be discarded.","category":"page"},{"location":"","page":"Home","title":"Home","text":"  The percentage of random numbers generated in step 4 and discarded in step 5a in above pseudo code for The Rejection Method can approach 50%. Cai[3] then develops an algorithm, called the Direct Method for systems with delays, in which no random variables are discarded.","category":"page"},{"location":"","page":"Home","title":"Home","text":"  The principle of Direct Method is the same as that of the original Gillespie Algorithm and the Rejection Method above: use one random variable to calculate when the next reaction initiates and use another random variable to calculate which reaction occurs at that future time. However, Direct Method updates the state of the system and propensity functions due to stored delayed reactions during the search for the next initiation time. In this way he ensures that no random variables are discarded as in the Rejection Method.","category":"page"},{"location":"","page":"Home","title":"Home","text":"  Suppose that at time t there are ongoing delayed reactions set to complete at times t + T_1 t + T_2     t + T_d. Define T_0 = 0 and T_d+1 = infty.","category":"page"},{"location":"#Pseudo-code-2","page":"Home","title":"Pseudo code","text":"","category":"section"},{"location":"#Next-Reaction-Method-for-systems-with-delays","page":"Home","title":"Next Reaction Method for systems with delays","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"  Because the initiations are still given by the firing times of independent Poisson processes. Therefore, if T_k is the current internal time of Y_k, P_k the first internal time after T_k at which Y_k fires, and the propensity function for the kth reaction channel is given by a_k, then the time until the next initiation of reaction k(assuming no other reactions initiate or complete) is still given by Delta t_k= (P_kT_k)a_k. The only change to the algorithm will be in keeping track and storing the delayed completions. To each delayed reaction channel we therefore assign a vector, s_k, that stores the completion times of that reaction in ascending order. Thus, the time until there is a change in the state of the system, be it an initiation or a completion, will be given by:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Delta = minDelta t_k s_k(1)  t","category":"page"},{"location":"","page":"Home","title":"Home","text":"  where t is the current time of the system. These ideas form the heart of our Next Reaction Method[4] for systems with delays.","category":"page"},{"location":"#Pseudo-code-3","page":"Home","title":"Pseudo code","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Initialize. Set the initial number of molecules of each species and set t = 0. For each k  M, set P_k = 0 and T_k = 0, and for each delayed reaction channel set s_k = infty.\nCalculate the propensity function, a_k, for each reaction.\nGenerate M independent, uniform(01) random numbers, r_k, and set P_k = ln(1r_k).\nSet Delta t_k = (P_k  T_k)a_k.\nSet Delta = min_kDelta t_k s_k(1)  t.\nSet t = t + Delta.\nIf we chose the completion of the delayed reaction mu:\nUpdate the system based upon the completion of the reaction mu.\nDelete the first row of S_mu.\nElseif reaction mu initiated and muin ND\nUpdate the system according to reaction mu.\nElseif reaction mu initiated and muin CD\nUpdate sµ by inserting t + tau_mu into s_mu in the second to last position.\nElseif reaction mu initiated and muin ICD\nUpdate the system based upon the initiation of reaction mu.\nUpdate s_mu by inserting t + tau_mu into s_mu in the second to last position.\nFor each k, set T_k = T_k + a_k Delta.\nIf reaction mu initiated, let r be uniform(01) and set P_µ = P_µ + ln(1r).\nRecalculate the propensity functions, a_k.\nReturn to step 4 or quit.","category":"page"},{"location":"#References-2","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]: Dmitri A. Bratsun, Dmitri N. Volfson, Jeff Hasty, and Lev S. Tsimring \"Non-Markovian processes in gene regulation (Keynote Address)\", Proc. SPIE 5845, Noise in Complex Systems and Stochastic Dynamics III, (23 May 2005); https://doi.org/10.1117/12.609707","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2]:  Manuel Barrio,Kevin Burrage ,André Leier,Tianhai Tian. \"Oscillatory Regulation of Hes1: Discrete Stochastic Delay Modelling and Simulation\", PLoS Computational Biology, 10.1371(2006)https://doi.org/10.1371/journal.pcbi.0020117","category":"page"},{"location":"","page":"Home","title":"Home","text":"[3]: Xiaodong Cai, \"Exact stochastic simulation of coupled chemical reactions with delays\", The Journal of Chemical Physics 126, 124108(2007). https://doi/10.1063/1.2710253.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[4]: David F. Anderson, \"A modified Next Reaction Method for simulating chemical systems with time dependent propensities and delays\", The Journal of Chemical Physics 128, 109903(2008). https://doi/10.1063/1.2799998.","category":"page"},{"location":"#Theory","page":"Home","title":"Theory","text":"","category":"section"},{"location":"#Exact-SSA-For-Coupled-Chemical-Reaction-Without-Delays","page":"Home","title":"Exact SSA For Coupled Chemical Reaction Without Delays","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"  Consider a system consisting of N1 chemical species, X_1     X_N, undergoing M  1 chemical reactions through reaction channels R_1R_M, each of which is equipped with a propensity function (or intensity function in the mathematics literature), a_k(X). The dynamic state of this chemical system can be described by the state vector X(t) =X_1(t)X_N(t)^T, where X_ntn = 1N is the number of X_n molecules at time t, and ^T denotes the transpose of the vector in the bracket.","category":"page"},{"location":"","page":"Home","title":"Home","text":"  Following Gillespie, A the dynamics of reaction R_m defined by a state-change vector nu_m = nu_1m nu_Nm^T, where nu_nm gives the changes in the X_n molecular population produced by one R_m reaction, and a propensity function a_m(t) together with the fundamental premise of stochastic chemical kinetics:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginequation\nbeginaligned\na_m(t)dt = mathrmthe probability given X(t)=x \n mathrmthat one reaction R_m mathrm will occur in the\n mathrmnext infinitesimal time interval tt+d_t\nendaligned\nendequation","category":"page"},{"location":"","page":"Home","title":"Home","text":"  Defining the probability rate constant c_m as the probability that a randomly selected combination of R_m reactant molecules reacts in a unit time period, we can calculate  a_m(t) fromcmand the molecular numbers ofRmreactants at time t using the method given by Gillespie.","category":"page"},{"location":"","page":"Home","title":"Home","text":"  For a chemical system in a given state X(t)=x at time t,assuming that all reactions occur instantly, Gillespie’s exact SSA answers the following two questions: (i)  when will the next reaction occur?  (ii)  which reaction will occur? Specifically, Gillespie’s exact SSA simulates the following event in each step:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginequation\nbeginaligned\nmathrmE  mathrmno reaction occurs in the time interval tt+tau\n mathrmand a reaction R_mu  mathrmoccurs in the infinitesimal\n mathrmtime interval t+taut+tau+d_tau\nendaligned\nendequation","category":"page"},{"location":"","page":"Home","title":"Home","text":"  Based upon the fundamental premise (1), Gillespie showed that that tau and mu are two independent random variables and have the following probability density functions (PDFs), respectively:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginequation\nf_tau(tau)=a_0(t) exp(-a_0(t)tau) tau  0\nendequation","category":"page"},{"location":"","page":"Home","title":"Home","text":"and","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginequation\nf_mu(mu)=a_mu(t)a_0(t) mu = 1M\nendequation","category":"page"},{"location":"","page":"Home","title":"Home","text":"where a_0(t)=beginmatrix sum_m=1^M a_m(t) endmatrix. According to the PDF (4), a realization of mu can be generated from a standard uniform random variable u_1, by taking mu to be the integer for which beginmatrix sum_j=1^mu-1 a_j(t) endmatrix  u_1 a_0(t)  beginmatrix sum_j=1^mu a_j(t) endmatrix;based on the PDF (3), a realization of taucan be generated from another standard uniform random variable u_2 as tau=ln(u_2)a_0(t). Therefore, Gillespie’s exact SSA generates a realization of mu and tau in each step of simulation, and then updates the time and system state as tleftarrow t+tau and  mathbfx leftarrow mathbfx+ mathbfnu_mu, respectively.","category":"page"},{"location":"#Exact-SSA-For-Coupled-Chemical-Reaction-With-Delays","page":"Home","title":"Exact SSA For Coupled Chemical Reaction With Delays","text":"","category":"section"},{"location":"#Direct-method","page":"Home","title":"Direct method","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"  As in the derivation of Gillespie’s exact SSA, we first need to find the probability of event (2), that is defined as P(taumu)dtau, where P(taumu) is the joint PDF of tau and mu. Suppose that there are d ongoing reactions at timet, which will finish at t+T_1t+T_d, respectively. Without loss of generality, we assume that T_1T_2T_d. Unlike in the reaction system without delays where the propensity functions remain unchanged in the time interval tt+tau, the propensity functions here change at t+T_ii=1d, due to delayed reactions. We need to take into account such changes in propensity functions when deriving  P(taumu).","category":"page"},{"location":"","page":"Home","title":"Home","text":"  As in the derivation of Gillespie’s exact SSA, P(taumu)dtau can be found from the fundamental premise(1) as","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginequation\nP(taumu)dtau=P_0(tau) a_mu(taumu)dtau\nendequation","category":"page"},{"location":"","page":"Home","title":"Home","text":"where P_0(tau) is the probability that no reaction will occur in the time interval tt+tau, while a_mu(t+tau)dtau is the probability that a reaction R_mu occurs in t+taut+tau+dtau. Defining T_0=0 and T_d+1=infty, we can find P_0(tau) for tau that lies in different time intervals T_iT_i+1)i=0d. If tau in T_iT_i+1), we define the event E_j as the event that no reaction occurs in the time interval t+T_jt+T_j+1)j=0j=i1, respectively,and the event  E_i  as the event that no reaction occurs in the time interval t+T_it+tau). Then, we can express P_0(tau) as","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginequation\nP_0(tau)=P(E_0E_i)=P(E_0) prod_j=1^i P(E_j丨E_0E_j-1)\nendequation","category":"page"},{"location":"","page":"Home","title":"Home","text":"  From the derivation of Gillespie’s exact SSA,we know that  P(E_0) = exp (a_0(t)T_1),  P(E_j丨E_0E_j-1) = exp(-a_0(t+T_j)T_1)  (T_j+1T_j)j=0i1,   and   P(E_i丨E_0E_i-1) = exp(-a_0(t+T_i)(tau-T_i)).  Notice that propensity functions change at t+T_j after a delayed reaction finishes, and we use a_0(t+T_j) to represent the new a_0. The probability P_0(tau) is then given by","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginequation\nbeginaligned\nP_0(tau)= exp bigg (-beginmatrix sum_j=0^i-1 a_0(t+T_j)(T_j+1-T_j) endmatrix-a_0(t+T_i)(tau-T_i)) \ntau in T_iT_i+1) i = 0d\nendaligned\nbeginequation","category":"page"},{"location":"","page":"Home","title":"Home","text":"where we assume that the first term of the exponent is equal to zero when i = 0. Since P_0(tau) does not depend on individual propensity functions, as shown in Eq.(7), it is seen from Eq.(5) that tau and mu are independent random variables. Combining Eqs.(5) and (7) and noticing that a_mu(t+tau)=a_mu(t+T_i) for tau in T_iT_i+1), we obtain the PDF of tau and mu as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginequation\nbeginaligned\nf_tau(tau)=a_0(t+T_i)exp(-beginmatrix sum_j=0^i-1 a_0(t+T_j)(T_j+1-T_j) endmatrix-a_0(t+T_i)(tau-T_i)) \ntau in T_iT_i+1) i = 0d\nendaligned\nbeginequation","category":"page"},{"location":"","page":"Home","title":"Home","text":"and","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginequation\nf_mu(mu)=a_mu(t+T_i)a_0(t+T_i) mu = 1Mtau in T_iT_i+1)\nbeginequation","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is not difficult to verify that int_0^infty f_tau(tau) dtau = 1. In simulation, mu can be generated, from a standard uniform random variable u_1, by taking mu to be the integer for which beginmatrix sum_j=1^mu-1 a_j(t+T_i) endmatrix  u_1 a_0(t+T_i)  beginmatrix sum_j=1^mu a_j(t+T_i) endmatrix,after tau is generated to be in the time interval T_iT_i+1).We next derive the method of generating  tau according to its PDF in Eq.(8).","category":"page"},{"location":"","page":"Home","title":"Home","text":"  The cumulative distribution function of taucan be found from Eq.(8) as","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginequation\nbeginaligned\nF_tau(tau)=1 - exp(-beginmatrix sum_j=0^i-1 a_0(t+T_j)(T_j+1-T_j) endmatrix-a_0(t+T_i)(tau-T_i)) \ntau in T_iT_i+1) i = 0d\nendaligned\nbeginequation","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, we can generate tau from a standard uniform random variable u_2, by taking tau=F_tau^1(u2), where F_tau^1(cdot) represents the inverse of F_tau(tau). More specifically, we can obtain tau as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"  Find T_i such that  F_tau(T_i)  u_2  F_tau(T_i+1), then calculate  tau from","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginequation\nbeginaligned\ntau = T_i + -ln (1-u_2)-beginmatrix sum_j=0^i-1 a_0(t+T_j)(T_j+1-T_j)  over a_0(t+T_j) \ntau in T_iT_i+1)\nendaligned\nbeginequation","category":"page"},{"location":"#MyPkg","page":"Home","title":"MyPkg","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MyPkg.","category":"page"},{"location":"#introduction","page":"Home","title":"introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"用Simpson积分计算公式计算被积函数f的积分区间为[a, b]定积分","category":"page"},{"location":"#content","page":"Home","title":"content","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"两个pages的目录","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\",\"Library.md\"]","category":"page"},{"location":"#function","page":"Home","title":"function","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Simpson(f, a, b)","category":"page"},{"location":"#MyPkg.Simpson-Tuple{Any, Any, Any}","page":"Home","title":"MyPkg.Simpson","text":"function Simpson(f, a, b)\n\nCalculate the integral f function from x to y by Simpson formula\n\nHere's Simpson expression:\n\n`Simpson(f, a, b) = \\frac{(b-a)}{6} * (f(a) + 4*f(\\frac{(a+b)}{2}) + f(b))\n\nArguments\n\nf::Express: integrand function\na::Float: left boundary of integral interval of definite integral\nb::Float: right boundary of integral interval of definite integral\n\nExamples\n\njulia> Simpson(2*x, 1, 2)\n4\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"find_num_in_vec(A::Vector, position_index::Vector{Int64}, x)","category":"page"},{"location":"#MyPkg.find_num_in_vec-Tuple{Vector{T} where T, Vector{Int64}, Any}","page":"Home","title":"MyPkg.find_num_in_vec","text":"function find_num_in_vec(A::Vector, position_index::Vector{Int64}, x)\n\nFind the number of values which in each vector elements equal to x according to the corresponding index position specified by the element in the position_index vector in the given vetcer A.\n\nExamples\n\njulia> A =  [[0.09,0.09,0.1],[0.3,0.09,0.1],[0.09]]\n3-element Vector{Vector{Float64}}:\n [0.09, 0.09, 0.1]\n [0.3, 0.09, 0.1]\n [0.09]\n\njulia> position_index =  [1,2,3]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> find_num_in_vec(A::Vector, position_index::Vector{Int64}, 0.09)\n3-element Vector{Int64}:\n2\n1\n1\n\n\n\n\n\n","category":"method"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"所有函数的索引","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
